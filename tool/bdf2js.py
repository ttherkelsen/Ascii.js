#!/usr/bin/env python3
#
# bdf2js.py -- convert BDF files into font definitions in JavaScript
#     suitable for use by jsascii
#

import argparse, re, os.path

GLYPH_TEMP = """// File autogenerated by bdf2js.py

const glyphs = {
%s
};

export { glyphs };
export default glyphs;
"""

META_TEMP = """// File autogenerated by bdf2js.py

const name = "%s";
const width = %d;
const height = %d;
const depth = 1;
const colours = [ "#000000ff", "#ffffffff" ];
const pages = new Set([ %s ]);
const properties = [ 'name', 'width', 'height', 'depth', 'colours', 'pages' ];

export { name, width, height, depth, colours, pages, properties };
"""

FULL_TEMP = """// File autogenerated by bdf2js.py

import Font from "../../Font.js";

let font_%s = new Font({
    name: "%s",
    width: %d,
    height: %d,
    depth: 1,
    colours: [ "#000000ff", "#ffffffff" ],
    pages: new Set([ %s ]),
    glyphs: {
%s
    },
});

export default font_%s;
export { font_%s };
"""

def run():
    cmdline = argparse.ArgumentParser(description="Convert BDF files into jsascii javascript font definitions.")
    cmdline.add_argument('-d', '--destdir', help='Which directory to write the files to, defaults to current dir.', default=".")
    cmdline.add_argument('bdffile', help='BDF file to convert')
    args = cmdline.parse_args()

    convert(args.bdffile, args.destdir)

def convert(bdf, destdir):
    RE = r'STARTCHAR (\S+).+?ENCODING (\S+).+?BBX (\d+) (\d+).+?BITMAP\s+(.*?)\s+ENDCHAR'
    TEMPLATE = '    %s: %r,'
    fontname = os.path.basename(bdf).split(".")[0]
    glyphs = {}

    # FIXME: We assume that the BDF font format has the same size
    # bitmap for all font glyphs.  Is this a safe assumption?
    with open(bdf, 'r') as fd:
        for match in re.finditer(RE, fd.read(), re.DOTALL):
            name, encoding, width, height, bitmap = match.groups()
            encoding = int(encoding)
            width = int(width)
            height = int(height)
            shift = 8 - (width % 8)
            bitmap = [ int(t, 16) >> shift for t in bitmap.split("\n") ]

            if len(bitmap) != height:
                raise ValueError("%s bitmap has wrong size" % name)
          
            page = encoding >> 8
            if page not in glyphs:
                glyphs[page] = [ None ]*256
            
            glyphs[page][encoding % 256] = bitmap

    with open(os.path.join(destdir, "meta.js"), 'w') as fd:
        print(META_TEMP % (fontname, width, height, ", ".join([ str(t) for t in glyphs.keys() ])), file=fd)

    allglyphs = []
    for page in sorted(glyphs.keys()):
        glist = []
        idx = -1
        for bitmap in glyphs[page]:
            idx += 1
            if bitmap is None:
                continue
            glist.append(TEMPLATE % ((page << 8) + idx, bitmap))
        with open(os.path.join(destdir, '%s.js' % page), 'w') as fd:
            print(GLYPH_TEMP % ("\n".join(glist)), file=fd)
        allglyphs.extend(glist)

    with open(os.path.join(destdir, "full.js"), 'w') as fd:
        print(
            FULL_TEMP % (
                fontname, fontname, width, height,
                ", ".join([ str(t) for t in glyphs.keys() ]), "\n".join(allglyphs),
                fontname, fontname
            ),
            file=fd
        )

if __name__ == '__main__':
    run()
